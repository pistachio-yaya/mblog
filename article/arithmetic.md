---
title:arithmetic--排序算法
tags:插入排序
category:javascript
---

## 时间复杂度
前两天去面试，提到时间复杂度，由此再学习一次时间复杂度相关知识，希望有更深入一层的理解。
百度百科对时间复杂度的定义:在计算机科学当中，算法的时间复杂度是一个函数，描述了该算法的运行时间。

算法时间复杂度的定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况确定n的数量级。算法的时间复杂度也就是算法的时间量度，记作：T(n) = O(f(n))。他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

那么现在的问题就是确定f(n)的增长率。具体步骤如下：

1. 用常数1代替所有的常数项
2. 只保留最高阶项
3. 如果最高阶项存在且不为1，则去除他的常数倍数
4. 得到结果

下面我们就来分析一下排序算法的时间复杂度！

## 算法基础--冒泡排序

冒泡排序对于少量元素的排序是一个有效的算法。冒泡排序是一种交换排序，基本原理是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。

## 代码块

```
function bubleSort(arr){
	for(var i = 0;i < arr.length;i++){
		for(var j = i;j < arr.length; j++){
			if(i < j){
				var temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
		}
	return arr;    
}

var arr=[7,4,3,1,2,9,6];
bubbleSort(arr);   // [9, 7, 6, 4, 3, 2, 1]
```

从以上代码当中可以看出，有两层循环，假定数组的length为n，所以当i = 0时执行n次，当i = 1时，执行n - 1次。以此类推内层执行了n + (n - 1) + (n - 2) +...+ 2 + 1次，可以看出这是一个等差数列，可以用等差数列的求和公式计算，即：n(n + 1)/2或n^2/2 + n/2。由上述的时间复杂度计算步骤可以得到冒泡排序的时间复杂度为：O(n^2)。


## 算法基础--快速排序

快速排序是处理大数据集最快的排序算法之一。快速排序的原理是：通过一趟排序将待排记录分割成独立的两部分，一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。快速排序是冒泡排序的升级，他们都属于选择排序类，是通过不断的比较移动和交换来实现排序的，只不过快速排序的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，将关键字较小的记录从后面直接移动到前面，从而减少了比较的次数和移动交换的次数。

## 代码块

```
function qSort(arr){
	if (arr.length===0){
		return arr;
	}
	var lesser=[];
	var greater=[];
	var pivot=arr[0];
	for (var i=1;i<arr.length;i++){
		if(arr[i]<pivot){
			lesser.push(arr[i]);
		}
		else{
			greater.push(arr[i]);
		}
	}
	return qSort(lesser).concat(pivot,qSort(greater));
}

var arr=[3,9,4,6,2,1,7];
qSort(arr);       // [1,2,3,4,6,7,9]

```

快速排序的时间复杂度分析：快速排序的时间性能取决于快速排序递归的深度。画出递归树即可看出从第二层开始，节点的个数是2^1、2^2、2^3....依此类推，如果节点上有n个数，则2^x = n,即x = log^n,以2为底。所以从第二层开始的递归次数是log^n;即：快速排序的时间复杂度为log^n,以2为底。
由于关键字的比较和交换是跳跃进行的，快速排序是不稳定排序。
待更新、、、
